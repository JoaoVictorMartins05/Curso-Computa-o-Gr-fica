declare type EventInit = {
    properties?: Record<string, any>;
};
declare type EventInterface = {
    readonly type: string;
};
declare class Event implements EventInterface {
    readonly type: string;
    constructor(type: string, options?: EventInit);
    protected defineProperties(properties: Record<string, any>): void;
}

declare type BaseEventsMap<E extends EventInterface = EventInterface> = {
    [eventType: string]: (event: E) => any;
};
declare type Keys<T> = Extract<keyof T, string>;
declare type OffEvent = () => void;
declare type Options = {
    validEventTypes?: (string | RegExp)[];
    triggerLastEvent?: boolean;
};
declare type GetFirstParameter<Func extends (...args: any) => any> = Parameters<Func>[0];
declare type GetObjectValues<T extends Record<string, any>> = T[keyof T];
declare type GetEventObjects<EventsMap extends Record<string, any>> = GetFirstParameter<GetObjectValues<EventsMap>>;
declare class EventDispatcher<EventsMap extends Record<string, any> = BaseEventsMap> {
    private readonly validEventTypes;
    private callbacks;
    private lastEvents;
    private disabled;
    private callbackContext;
    private triggerLastEvent;
    /**
     * Create a EventDispatcher instance.
     */
    constructor({ validEventTypes, triggerLastEvent }?: Options);
    /**
     * Set the context used when triggering callbacks.
     */
    setCallbackContext(context: object): this;
    /**
     * Register an event handler function for one or more events.
     *
     * @param eventType
     * One or more event types.
     *
     * @param callback
     * The callback function to be bound.
     *
     * @param options
     * triggerLastEvent: If set to true, trigger the callback immediately if there is a last event object.
     */
    on<EventType extends Keys<EventsMap>>(eventType: EventType, callback: EventsMap[EventType], options?: {
        triggerLastEvent?: boolean;
    }): OffEvent;
    /**
     * Remove the event handler.
     *
     * @param eventType
     * One or more event types.
     *
     * @param callback
     * The callback function to be removed.
     * If not provided, all callback functions of the given event type(s) get removed.
     */
    off<EventType extends Keys<EventsMap>>(eventType: EventType, callback?: EventsMap[EventType]): this;
    /**
     * Similar to `this.on` Define a one time event.
     */
    one<EventType extends Keys<EventsMap>>(eventType: EventType, callback: EventsMap[EventType], options?: {
        triggerLastEvent?: boolean;
    }): OffEvent;
    /**
     * Trigger the given event(s).
     * The arguments passed to the callback function.
     */
    trigger<EventObject extends GetEventObjects<EventsMap>>(eventObject: EventObject): ReturnType<EventsMap[keyof EventsMap]>[] | null;
    trigger<EventType extends Keys<EventsMap>>(eventType: EventType, args?: Record<string, any>): ReturnType<EventsMap[EventType]>[] | null;
    getLastEventObjectOf<EventType extends Keys<EventsMap>>(eventType: EventType): GetFirstParameter<EventsMap[EventType]> | null;
    removeLastEventObjectOf<EventType extends Keys<EventsMap>>(eventType: EventType): GetFirstParameter<EventsMap[EventType]> | null;
    /**
     * Disable triggering events.
     */
    disable(): this;
    /**
     * Enable triggering events.
     */
    enable(): this;
    /**
     * Clear all the registered callbacks.
     */
    clear(): this;
    /**
     * Get the callbacks for the given event name.
     */
    callbacksForEvent<EventType extends Keys<EventsMap>>(eventType: EventType): Set<EventsMap[EventType]>;
    /**
     * Determine if the given event type has callback functions.
     */
    private hasCallbacks;
    /**
     * Throw an error if the given event type(s) is not valid.
     */
    private validateEventType;
    /**
     * Determine if the given event type(s) is(are) valid.
     *
     * @param {(string|string[])} eventType
     * @returns {boolean}
     */
    private isValidEvent;
    Api(): {
        new (): {
            eventDispatcher: EventDispatcher<EventsMap>;
            on<EventType extends Extract<keyof EventsMap, string>>(eventType: EventType, fn: EventsMap[EventType]): OffEvent;
            off<EventType_1 extends Extract<keyof EventsMap, string>>(eventType: EventType_1, fn?: EventsMap[EventType_1] | undefined): this;
            one<EventType_2 extends Extract<keyof EventsMap, string>>(eventType: EventType_2, fn: EventsMap[EventType_2]): OffEvent;
            trigger<EventObject extends Event>(eventObject: EventObject): ReturnType<EventsMap[keyof EventsMap]>[] | null;
            trigger<EventType_3 extends Extract<keyof EventsMap, string>>(eventType: EventType_3, args?: Record<string, any> | undefined): ReturnType<EventsMap[EventType_3]>[] | null;
        };
    };
}

export { Event, EventDispatcher, EventInit, EventInterface };
