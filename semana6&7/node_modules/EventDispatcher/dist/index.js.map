{
  "version": 3,
  "sources": ["../src/Event.ts", "../src/TypeGuards.ts", "../src/EventDispatcher.ts"],
  "sourcesContent": ["export type EventInit = {\n  properties?: Record<string, any>\n}\n\nconst defaultEventInit = {\n  properties: {},\n}\n\nexport type EventInterface = { readonly type: string }\n\nexport class Event implements EventInterface {\n  public readonly type: string\n\n  constructor(type: string, options?: EventInit) {\n    const mergedOptions = { ...defaultEventInit, ...options }\n    this.type = type\n    this.defineProperties(mergedOptions.properties)\n  }\n\n  protected defineProperties(properties: Record<string, any>) {\n    for (const property in properties) {\n      ;(this as any)[property] = properties[property]\n    }\n  }\n}\n", "import { EventInterface } from './Event'\n\nexport function isArray<T = any>(obj: any): obj is Array<T> {\n  if (Array.isArray) {\n    return Array.isArray(obj)\n  }\n  return Object.prototype.toString.call(obj) === '[object Array]'\n}\n\nexport function isRegexp(obj: any): obj is RegExp {\n  return Object.prototype.toString.call(obj) === '[object RegExp]'\n}\n\nexport function isFunction<T = Function>(obj: any): obj is T {\n  return typeof obj === 'function'\n}\n\nexport function isString(obj: any): obj is string {\n  return typeof obj === 'string'\n}\n\nexport function isEventObject(value: any): value is EventInterface {\n  return typeof value === 'object' && 'type' in value\n}\n", "import { EventInterface, Event } from './Event'\nimport { isRegexp, isArray, isEventObject } from './TypeGuards'\n\ntype BaseEventsMap<E extends EventInterface = EventInterface> = {\n  [eventType: string]: (event: E) => any\n}\n\ntype Keys<T> = Extract<keyof T, string>\n\ntype OffEvent = () => void\ntype Options = {\n  validEventTypes?: (string | RegExp)[]\n  triggerLastEvent?: boolean\n}\n\ntype GetFirstParameter<Func extends (...args: any) => any> = Parameters<Func>[0]\ntype GetObjectValues<T extends Record<string, any>> = T[keyof T]\ntype GetEventObjects<EventsMap extends Record<string, any>> = GetFirstParameter<GetObjectValues<EventsMap>>\n\nexport class EventDispatcher<EventsMap extends Record<string, any> = BaseEventsMap> {\n  private readonly validEventTypes: (string | RegExp)[]\n  private callbacks: { [EventType in keyof EventsMap]: Set<EventsMap[EventType]> } = {} as any\n  private lastEvents: { [EventType in keyof EventsMap]: GetFirstParameter<EventsMap[EventType]> } = {} as any\n  private disabled: boolean = false\n  private callbackContext: object\n  private triggerLastEvent: boolean\n\n  /**\n   * Create a EventDispatcher instance.\n   */\n  constructor({ validEventTypes = [/.*/], triggerLastEvent = false }: Options = {}) {\n    // If provided a array for validate event type set it up.\n    // `event-type` could be either a string or regular expression\n    this.validEventTypes = validEventTypes\n    this.triggerLastEvent = triggerLastEvent\n    this.callbackContext = this\n  }\n\n  /**\n   * Set the context used when triggering callbacks.\n   */\n  setCallbackContext(context: object): this {\n    this.callbackContext = context\n\n    return this\n  }\n\n  /**\n   * Register an event handler function for one or more events.\n   *\n   * @param eventType\n   * One or more event types.\n   *\n   * @param callback\n   * The callback function to be bound.\n   *\n   * @param options\n   * triggerLastEvent: If set to true, trigger the callback immediately if there is a last event object.\n   */\n  on<EventType extends Keys<EventsMap>>(\n    eventType: EventType,\n    callback: EventsMap[EventType],\n    options?: { triggerLastEvent?: boolean }\n  ): OffEvent {\n    this.validateEventType(eventType)\n\n    const triggerLastEvent = options?.triggerLastEvent || this.triggerLastEvent\n\n    // Add fn to callback list\n    if (!this.hasCallbacks(eventType)) {\n      this.callbacks[eventType] = new Set()\n    }\n\n    this.callbacks[eventType].add(callback)\n\n    if (triggerLastEvent) {\n      const lastEventObject = this.getLastEventObjectOf(eventType)\n      lastEventObject && callback.call(this.callbackContext || this, lastEventObject)\n    }\n\n    const off = () => {\n      this.off(eventType, callback)\n    }\n\n    return off\n  }\n\n  /**\n   * Remove the event handler.\n   *\n   * @param eventType\n   * One or more event types.\n   *\n   * @param callback\n   * The callback function to be removed.\n   * If not provided, all callback functions of the given event type(s) get removed.\n   */\n  off<EventType extends Keys<EventsMap>>(eventType: EventType, callback?: EventsMap[EventType]): this {\n    this.validateEventType(eventType)\n\n    // Error handling\n    if (!this.hasCallbacks(eventType)) {\n      return this\n    }\n\n    // Delete all related callbacks if `callback` not specified\n    if (!callback) {\n      delete this.callbacks[eventType]\n      return this\n    }\n\n    // Otherwise delete only the `callback` from callback list\n    this.callbacks[eventType].delete(callback)\n\n    return this\n  }\n\n  /**\n   * Similar to `this.on` Define a one time event.\n   */\n  one<EventType extends Keys<EventsMap>>(\n    eventType: EventType,\n    callback: EventsMap[EventType],\n    options?: { triggerLastEvent?: boolean }\n  ): OffEvent {\n    this.validateEventType(eventType)\n\n    const onetimeCallback = (eventObject: EventInterface) => {\n      this.off(eventType, onetimeCallback as EventsMap[EventType])\n      return callback.call(this.callbackContext || this, eventObject)\n    }\n\n    return this.on(eventType, onetimeCallback as EventsMap[EventType], options)\n  }\n\n  /**\n   * Trigger the given event(s).\n   * The arguments passed to the callback function.\n   */\n  trigger<EventObject extends GetEventObjects<EventsMap>>(\n    eventObject: EventObject\n  ): ReturnType<EventsMap[keyof EventsMap]>[] | null\n  trigger<EventType extends Keys<EventsMap>>(\n    eventType: EventType,\n    args?: Record<string, any>\n  ): ReturnType<EventsMap[EventType]>[] | null\n  trigger(eventTypeOrEventObject: Keys<EventsMap> | EventInterface, args?: Record<string, any>): any {\n    const eventObject = isEventObject(eventTypeOrEventObject)\n      ? eventTypeOrEventObject\n      : new Event(eventTypeOrEventObject, { properties: args || {} })\n\n    const eventType = (isEventObject(eventTypeOrEventObject)\n      ? eventTypeOrEventObject.type\n      : eventTypeOrEventObject) as Keys<EventsMap>\n\n    this.validateEventType(eventType)\n\n    this.lastEvents[eventType] = eventObject\n\n    if (this.disabled || !this.hasCallbacks(eventType)) {\n      return null\n    }\n\n    const callbacks = this.callbacksForEvent(eventType)\n\n    const responses = Array.from(callbacks).map((callback) => {\n      return callback.call(this.callbackContext || this, eventObject)\n    })\n\n    return responses\n  }\n\n  getLastEventObjectOf<EventType extends Keys<EventsMap>>(\n    eventType: EventType\n  ): GetFirstParameter<EventsMap[EventType]> | null {\n    if (eventType in this.lastEvents) {\n      return this.lastEvents[eventType]\n    }\n\n    return null\n  }\n\n  removeLastEventObjectOf<EventType extends Keys<EventsMap>>(\n    eventType: EventType\n  ): GetFirstParameter<EventsMap[EventType]> | null {\n    if (eventType in this.lastEvents) {\n      const lastEvent = this.lastEvents[eventType]\n      delete this.lastEvents[eventType]\n\n      return lastEvent\n    }\n\n    return null\n  }\n\n  /**\n   * Disable triggering events.\n   */\n  disable(): this {\n    this.disabled = true\n    return this\n  }\n\n  /**\n   * Enable triggering events.\n   */\n  enable(): this {\n    this.disabled = false\n    return this\n  }\n\n  /**\n   * Clear all the registered callbacks.\n   */\n  clear(): this {\n    this.callbacks = {} as any\n\n    return this\n  }\n\n  /**\n   * Get the callbacks for the given event name.\n   */\n  callbacksForEvent<EventType extends Keys<EventsMap>>(eventType: EventType): Set<EventsMap[EventType]> {\n    return this.callbacks[eventType]\n  }\n\n  /**\n   * Determine if the given event type has callback functions.\n   */\n  private hasCallbacks(eventType: string): boolean {\n    return eventType in this.callbacks\n  }\n\n  /**\n   * Throw an error if the given event type(s) is not valid.\n   */\n  private validateEventType(eventType: string | string[]): void {\n    if (!this.isValidEvent(eventType)) {\n      const validEvents = this.validEventTypes.join('|')\n      throw new Error(`Invalid Event Type: '${eventType}'.\\nEvent type should be any of: ${validEvents}.`)\n    }\n  }\n\n  /**\n   * Determine if the given event type(s) is(are) valid.\n   *\n   * @param {(string|string[])} eventType\n   * @returns {boolean}\n   */\n  private isValidEvent(eventType: string | string[]): boolean {\n    let validEventCount = 0\n    const eventTypes = asArray(eventType)\n\n    for (let eventType of eventTypes) {\n      for (let validEvent of this.validEventTypes) {\n        let isValid\n        if (isRegexp(validEvent)) {\n          isValid = validEvent.test(eventType)\n        } else {\n          isValid = eventType === validEvent\n        }\n        if (isValid) {\n          validEventCount++\n          if (validEventCount === eventTypes.length) {\n            return true\n          }\n        }\n      }\n    }\n\n    return false\n  }\n\n  Api() {\n    const { validEventTypes, triggerLastEvent } = this\n    const createInstance = () => {\n      return new EventDispatcher<EventsMap>({ validEventTypes, triggerLastEvent })\n    }\n\n    return class {\n      eventDispatcher: EventDispatcher<EventsMap>\n\n      constructor() {\n        this.eventDispatcher = createInstance()\n      }\n\n      on<EventType extends Keys<EventsMap>>(eventType: EventType, fn: EventsMap[EventType]): OffEvent {\n        return this.eventDispatcher.on(eventType, fn)\n      }\n\n      off<EventType extends Keys<EventsMap>>(eventType: EventType, fn?: EventsMap[EventType]): this {\n        this.eventDispatcher.off(eventType, fn)\n        return this\n      }\n\n      one<EventType extends Keys<EventsMap>>(eventType: EventType, fn: EventsMap[EventType]): OffEvent {\n        return this.eventDispatcher.one(eventType, fn)\n      }\n\n      trigger<EventObject extends Event>(\n        eventObject: EventObject\n      ): ReturnType<EventsMap[keyof EventsMap]>[] | null\n      trigger<EventType extends Keys<EventsMap>>(\n        eventType: EventType,\n        args?: Record<string, any>\n      ): ReturnType<EventsMap[EventType]>[] | null\n      trigger(eventTypeOrEventObject: any, args?: any): any {\n        return this.eventDispatcher.trigger(eventTypeOrEventObject, args)\n      }\n    }\n  }\n}\n\nfunction asArray(value: any): any[] {\n  return isArray(value) ? value : [value]\n}\n"],
  "mappings": "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",
  "names": []
}
