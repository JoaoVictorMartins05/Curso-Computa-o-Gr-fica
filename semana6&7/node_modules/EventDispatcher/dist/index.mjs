var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/Event.ts
var defaultEventInit = {
  properties: {}
};
var Event = class {
  constructor(type, options) {
    const mergedOptions = __spreadValues(__spreadValues({}, defaultEventInit), options);
    this.type = type;
    this.defineProperties(mergedOptions.properties);
  }
  defineProperties(properties) {
    for (const property in properties) {
      ;
      this[property] = properties[property];
    }
  }
};

// src/TypeGuards.ts
function isArray(obj) {
  if (Array.isArray) {
    return Array.isArray(obj);
  }
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function isRegexp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
function isEventObject(value) {
  return typeof value === "object" && "type" in value;
}

// src/EventDispatcher.ts
var EventDispatcher = class {
  constructor({validEventTypes = [/.*/], triggerLastEvent = false} = {}) {
    this.callbacks = {};
    this.lastEvents = {};
    this.disabled = false;
    this.validEventTypes = validEventTypes;
    this.triggerLastEvent = triggerLastEvent;
    this.callbackContext = this;
  }
  setCallbackContext(context) {
    this.callbackContext = context;
    return this;
  }
  on(eventType, callback, options) {
    this.validateEventType(eventType);
    const triggerLastEvent = (options == null ? void 0 : options.triggerLastEvent) || this.triggerLastEvent;
    if (!this.hasCallbacks(eventType)) {
      this.callbacks[eventType] = new Set();
    }
    this.callbacks[eventType].add(callback);
    if (triggerLastEvent) {
      const lastEventObject = this.getLastEventObjectOf(eventType);
      lastEventObject && callback.call(this.callbackContext || this, lastEventObject);
    }
    const off = () => {
      this.off(eventType, callback);
    };
    return off;
  }
  off(eventType, callback) {
    this.validateEventType(eventType);
    if (!this.hasCallbacks(eventType)) {
      return this;
    }
    if (!callback) {
      delete this.callbacks[eventType];
      return this;
    }
    this.callbacks[eventType].delete(callback);
    return this;
  }
  one(eventType, callback, options) {
    this.validateEventType(eventType);
    const onetimeCallback = (eventObject) => {
      this.off(eventType, onetimeCallback);
      return callback.call(this.callbackContext || this, eventObject);
    };
    return this.on(eventType, onetimeCallback, options);
  }
  trigger(eventTypeOrEventObject, args) {
    const eventObject = isEventObject(eventTypeOrEventObject) ? eventTypeOrEventObject : new Event(eventTypeOrEventObject, {properties: args || {}});
    const eventType = isEventObject(eventTypeOrEventObject) ? eventTypeOrEventObject.type : eventTypeOrEventObject;
    this.validateEventType(eventType);
    this.lastEvents[eventType] = eventObject;
    if (this.disabled || !this.hasCallbacks(eventType)) {
      return null;
    }
    const callbacks = this.callbacksForEvent(eventType);
    const responses = Array.from(callbacks).map((callback) => {
      return callback.call(this.callbackContext || this, eventObject);
    });
    return responses;
  }
  getLastEventObjectOf(eventType) {
    if (eventType in this.lastEvents) {
      return this.lastEvents[eventType];
    }
    return null;
  }
  removeLastEventObjectOf(eventType) {
    if (eventType in this.lastEvents) {
      const lastEvent = this.lastEvents[eventType];
      delete this.lastEvents[eventType];
      return lastEvent;
    }
    return null;
  }
  disable() {
    this.disabled = true;
    return this;
  }
  enable() {
    this.disabled = false;
    return this;
  }
  clear() {
    this.callbacks = {};
    return this;
  }
  callbacksForEvent(eventType) {
    return this.callbacks[eventType];
  }
  hasCallbacks(eventType) {
    return eventType in this.callbacks;
  }
  validateEventType(eventType) {
    if (!this.isValidEvent(eventType)) {
      const validEvents = this.validEventTypes.join("|");
      throw new Error(`Invalid Event Type: '${eventType}'.
Event type should be any of: ${validEvents}.`);
    }
  }
  isValidEvent(eventType) {
    let validEventCount = 0;
    const eventTypes = asArray(eventType);
    for (let eventType2 of eventTypes) {
      for (let validEvent of this.validEventTypes) {
        let isValid;
        if (isRegexp(validEvent)) {
          isValid = validEvent.test(eventType2);
        } else {
          isValid = eventType2 === validEvent;
        }
        if (isValid) {
          validEventCount++;
          if (validEventCount === eventTypes.length) {
            return true;
          }
        }
      }
    }
    return false;
  }
  Api() {
    const {validEventTypes, triggerLastEvent} = this;
    const createInstance = () => {
      return new EventDispatcher({validEventTypes, triggerLastEvent});
    };
    return class {
      constructor() {
        this.eventDispatcher = createInstance();
      }
      on(eventType, fn) {
        return this.eventDispatcher.on(eventType, fn);
      }
      off(eventType, fn) {
        this.eventDispatcher.off(eventType, fn);
        return this;
      }
      one(eventType, fn) {
        return this.eventDispatcher.one(eventType, fn);
      }
      trigger(eventTypeOrEventObject, args) {
        return this.eventDispatcher.trigger(eventTypeOrEventObject, args);
      }
    };
  }
};
function asArray(value) {
  return isArray(value) ? value : [value];
}
export {
  Event,
  EventDispatcher
};
//# sourceMappingURL=index.mjs.map
